# 6- Event Handling ##
Event is a messaging mechanism provided by the window system. Various kinds of 
events are generated by the window system for notifying the application. A key or 
mouse event is generated when the user presses or releases a key or mouse button, 
and the application can receive the event and response to user actions. 

The different window systems provide their own patterns of messaging mechanism. Nana 
implements an abstract pattern of event mechanism to hide the difference between different window systems. 

## 6.1, Registering and Unregistering an Event ###
To response to the click action generated by any specified button, we need to make the click event for the button. 

	#include <nana/gui/wvl.hpp> 
	#include <nana/gui/widgets/button.hpp> 
	void foo() { } 
	int main() 
	{ 
		using namespace nana::gui; 
		form fm; 
		fm.make_event<events::click>(foo); 
		exec(); 
	} 

As shown in above code, the make_event() is a member template of class widget, and it is 
used for registering an event handler. The above code makes a click event for the `form` object.
When the user clicks the body of the form, Nana is responsible for invoking the function `foo()` 
registered as a handler of the specified event. Additionally, the function `foo()` can be 
specified with a parameter of type `const nana::gui::eventinfo&` to receive the information 
of the event. The details of eventinfo are described in section 6.2. 

The make_event() returns a handle of event handler if the registration is successful. 
The type of the return value is nana::gui::event_handle. With the handle, we can delete the event handler manually. For example:

	event_handle handle = fm.make_event<events::click>(foo); 
	fm.umake_event(handle); 

After calling the umake_event(), the `foo()` function would be not invoked when the user clicks the body of form. 
In most situations, we could not take care of deleting the event handler, because the event handlers will be deleted while form is closed. 

## 6.2 Events ###
An event type describes a specific event which is generated by Nana. For each event type, 
a corresponding class is defined by Nana, which is used for referring to an event type. 
The classes for event types are defined in the namespace nana::gui::events, such as `click`, `mouse_move` and so on. 

Every event contains some information. The information is sent to the application through a (const) reference to an `eventinfo` object in event handler. 

	#include <nana/gui/wvl.hpp> 
	void foo(const nana::gui::eventinfo& ei) 
	{ 
		//Refer to ei for information of event. 
	} 
	int main() 
	{ 
		using namespace nana::gui; 
		form fm; 
		fm.make_event<events::click>(foo); 
		fm.show(); 
		exec(); 
	} 

Nana.GUI provides some raw events, such as `click`, `mouse_move` and so on. 
Most of these events can work with all widgets implemented by Nana.GUI, but some of them are individual, 
like `unload` for `root widget` and `elapse` for `timer`.

Every widget has an interface for registering an event, named `make_event`.

	  template<typename Event, typename Function>
	event_handle make_event(Function) const;

	  template<typename Event, typename Class, typename Concept>
	event_handle make_event(Class& object, 
	   void (Concept::*mf)(const  nana::gui::eventinfo&));

	  template<typename Event, typename Class, typename Concept>
	event_handle make_event(Class& object, void(Concept::*mf)());

These template function calls explicitly specifies the first template parameter. 
The Event is a type defined by Nana.GUI in nana::gui::events. The events are:

Event			|	Description
----------------|---------------------------------------
click			| A mouse click event.
dbl_click		| A mouse double click event.
mouse_enter		| A mouse enters a widget.
mouse_move		| A mouse moves over a widget.
mouse_leave		| A mouse leaves a widget.
mouse_down		| A mouse button is pressed on a widget.
mouse_up		| A mouse button is released on a widget.
mouse_wheel		| A mouse scrolls the wheel on a widget.
mouse_drop		| A mouse release over a window that is registered as recipient of drag and drop.
size			| A widget's size is changing.
unload			| A form is closed by clicking the X button, only works for root widget.
destroy			| A widget is about to be destroyed.
focus			| A widget's focus is changed.
key_down		| A keyboard is pressed on a focus widget.
key_char		| The focus widget received a character.
key_up			| A keyboard is released on a focus widget.
shortkey		| The widgets received a shortkey message.
elapse			| A widget received a tick that is sended by timer.
				
An user-defined event function may have a parameter of type `const nana::gui::eventinfo&` for queering the event information, such as mouse position.

	void foo();
	void foo_with_parameter(const nana::gui::eventinfo&);
	class user_def_functor
	{ public:
	   void operator()(const nana::gui::eventinfo&); 		 //user-defined function must have the parameter.
	};
	nana::gui::button().make_event<nana::gui::events::click>(foo);
	nana::gui::button().make_event<nana::gui::events::click>(foo_with_parameter);
	nana::gui::button().make_event<nana::gui::events::click>(user_def_functor());

`make_event` returns a handle for uninstalling the associated user-defined event function and Nana.GUI destroys the 
user-defined event function automatically when the widget is beginning to destroy.

This just describes these raw events, but some widgets like nana::gui::treebox provides some high-level events, 
such as expanding a node. These details are only described in its reference. 

For different events, the `eventinfo` contains different structures for these event types. The following paragraphs describe the details of eventinfo. 

### 6.2.1 Mouse Events ###
The mouse is an important and convenient input device. The user controls the mouse cursor 
on the screen through moving and clicking mouse. If the mouse cursor moves over on a widget, 
the system would generate a `mouse_move` event to notify the program to which the widget belongs. 
The structure of mouse events contains: 

	struct implemented-specified 
	{ 
		short x; 
		short y;            //point (x, y) coordinates in event widget 
		bool left_button;   //True if the left button is pressed. 
		bool mid_button;    //True if the middle button is pressed. 
		bool right_button;  //True if the right button is pressed. 
		bool shift;         //True if the shift key is pressed. 
		bool ctrl;          //True if the ctrl key is pressed. 
	}; 

The structure of mouse wheel event contains: 

	struct implemented-specified 
	{ 
		short x; 
		short y;            //point(x, y) coordinates in event widgets. 
		bool upwards;       //True if the wheel is upward rolls. 
		bool shift;         //True if the shift key is pressed 
		bool ctrl;          //True if ctrl key is pressed. 
	}; 

In an event handler function, we can refer to the structure by using eventinfo object. For example: 

	void foo(const nana::gui::eventinfo& ei) 
	{ 
		using namespace nana::gui; 
		switch(ei.identifier) 
		{ default: ei.mouse;           //refers to the structure of mouse events. 
				 break; 
		case events::mouse_wheel::identifier: 
				ei.wheel;           //refers to the structure of mouse_wheel event. 
				break; 
		} 
	} 

To receive a mouse event, register the event with a specific class which is defined in namespace nana::gui::events. 

	click/dbl_click 

When the user clicks mouse and the mouse cursor is in a widget, the widget receives a click event that is generated by Nana. 

	mouse_enter/mouse_move/mouse_leave 

This event is sent to a widget when the mouse cursor enters/leaves the widget. 

	mouse_down/mouse_up 

This event is sent when the user presses/releases/moves the mouse while the mouse cursor is in a widget. 
## 6.2.2, Keyboard Events ###
There are three different kinds of keyboard events in Nana C++ Library: key down, key up and character key down. 
A window system usually uses an input focus to represent a window which would receive the keyboard events. In general, a window which user clicks would be set to the input 
focus widow in Nana C++ Library, additionally, the program can determinate which window gets the input focus with calling nana::gui::API::set_focus().
 
The structure of keyboard event contains:
 
	struct implemented-specified 
	{ 
	  mutable nana::char_t 	key; 
	  mutable nana::bool 	ignore; 
	  unsigned char 		ctrl; 
	}; 

As the definition shown, the member key and ignore are defined as mutable, the feature will be explained later. 

	key_down/key_up 

When the users hit the keyboard, the mouse_down would be generated when the key is pressed down, and the mouse_up would be generated when the pressed key is released. 
key_char 
The key_char event is an abstract event. A window system usually translates the keys into characters. For example, to type a 
Chinese character usually needs to hit the keyboard more than one key, the window system translates these keys into a Chinese 
character and then a key_char event is generated and sent to the program. 
The two members, key and ignore, are defined as mutable in the structure of key event, is used for modifying the state of key_char event. 
During key_char is processing, if the member “ignore” is set to true, the Nana will igore the key. For example, when a program is designed 
to receive the number input, the program should test the key in key_char event, and set the “ignore” to true if the input char is not a digital.
Like blow code. 

	void only_digital_allowed(const nana::gui::eventinfo& ei) 
	{ 
		ei.ignore = (ei.key < ‘0’ || ei.key > ‘9’); 
	}
